#FLR4MFCL - R4MFCL built with FLR classes
#Copyright (C) 2018  Rob Scott

## Unexported local functions

generate.ESS<- function(x, ctrl, projdat2, sc_df){
  
  # projdat stuff for which no ESS is specified
  projdat_noess <- projdat2[is.element(projdat2$fishery, sc_df$fishery[is.na(sc_df$ess)]),]
  # projdat stuff with an ESS to be applied to length comps
  projdat_ess_l <- projdat2[is.element(projdat2$fishery, sc_df$fishery[!is.na(sc_df$ess)]) & 
                              is.element(projdat2$fishery, sc_df$fishery[sc_df$length]),]
  # projdat stuff with an ESS to be applied to weight comps
  projdat_ess_w <- projdat2[is.element(projdat2$fishery, sc_df$fishery[!is.na(sc_df$ess)]) & 
                              is.element(projdat2$fishery, sc_df$fishery[sc_df$weight]),]
  # add length and weight frequency data to the frq
  lengths <- seq(lf_range(x)["LFFirst"], by=lf_range(x)["LFWidth"], length=lf_range(x)["LFIntervals"])
  weights <- seq(lf_range(x)["WFFirst"], by=lf_range(x)["WFWidth"], length=lf_range(x)["WFIntervals"])
  
  projdat_ess_ll <- as.data.frame(lapply(projdat_ess_l, rep, each=length(lengths)))
  projdat_ess_ww <- as.data.frame(lapply(projdat_ess_w, rep, each=length(weights)))
  projdat_ess_ll$length <- lengths
  projdat_ess_ww$weight <- weights
  
  projdat2      <- rbind(projdat_noess, projdat_ess_ll, projdat_ess_ww)
  projdat2$freq <- 0
  
  for(ff in 1:n_fisheries(x))
    projdat2[projdat2$length==lf_range(x)["LFFirst"] & projdat2$fishery==ff,'freq'] <- ess(ctrl)[ff]
  
  return(projdat2)
}









#' generate
#'
#' generates modified input files for mfcl.
#' Currently works when projection years are scaled by a single reference year.
#' Use of mulitple reference years eg.2008:2012 may cause problems.
#'
#' @param x:    Either an object of class MFCLFrq or of class MFCLPar.
#' @param y:    Eitehr an object of class MFCLprojCtrl or MFCLPar as generated by makepar.
#'
#' @param ... Additional argument list that might not ever
#'  be used.
#'
#' @return Modified input file in accordance with projection settings.
#' 
#' @seealso \code{\link{projCtrl}} 
#' 
#' @export
#' @docType methods
#' @rdname generate-methods
#'
#' @examples
#' generate(MFCLFrq(), MFCLprojControl())
#' generate(MFCLPar(), MFCLPar())

setGeneric('generate', function(x, y, z, ...) standardGeneric('generate')) 



#' @rdname generate-methods
#' @aliases generate

setMethod("generate", signature(x="MFCLFrq", y="MFCLprojControl"), 
         function(x, y, ...){
            
            ctrl     <- y
            proj.yrs <- seq(fprojyr(ctrl), range(x)['maxyear']+nyears(ctrl))  #seq(range(x)['maxyear']+1, range(x)['maxyear']+nyears(ctrl))
            qtrs     <- sort(unique(freq(x)$month))
            
            week   <- rev(freq(x)$week)[1]
            if(!all(freq(x)$week==week))
              warning("Differences in week not accounted for in projection frq")
            
            if(length(caeff(ctrl))>1 & length(caeff(ctrl))!=n_fisheries(x))
              stop("Error: caeff values do not match number of fisheries")
            if(length(scaler(ctrl))>1 & length(scaler(ctrl))!=n_fisheries(x))
              stop("Error: scaler values do not match number of fisheries")
            
            #sc_df <- data.frame(fishery=1:n_fisheries(x), caeff  = caeff(ctrl), scaler = scaler(ctrl))
            sc_df <- data.frame(fishery=1:n_fisheries(x), caeff  = caeff(ctrl), scaler = scaler(ctrl), ess=ess(ctrl), 
                                length=tapply(freq(x)$length, freq(x)$fishery, function(tt){any(!is.na(tt))}), 
                                weight=tapply(freq(x)$weight, freq(x)$fishery, function(tt){any(!is.na(tt))}))
            
            avdata <- freq(x)[is.element(freq(x)$year, avyrs(ctrl)) & is.na(freq(x)$length) & is.na(freq(x)$weight) ,]
            avdata <- rbind(avdata, freq(x)[is.element(freq(x)$year, avyrs(ctrl)) & freq(x)$length %in% lf_range(x)['LFFirst'] ,],
                                    freq(x)[is.element(freq(x)$year, avyrs(ctrl)) & freq(x)$weight %in% lf_range(x)['WFFirst'] ,])
            avdata <- avdata[!duplicated(avdata[,1:7]),] # remove duplicates that can occur if you have both length and wgt freq data
            
            avdata$catch[avdata$catch == -1] <- NA
            avdata$effort[avdata$effort == -1] <- NA
            
            flts     <- as.numeric(colnames(tapply(avdata$catch,  list(avdata$month, avdata$fishery), sum, na.rm=T)))
            avcatch  <- sweep(tapply(avdata$catch,  list(avdata$month, avdata$fishery), mean, na.rm=T), 2, sc_df$scaler[flts], "*")
            aveffort <- sweep(tapply(avdata$effort, list(avdata$month, avdata$fishery), mean, na.rm=T), 2, sc_df$scaler[flts], "*")
            
            projdat  <- data.frame(year    = rep(proj.yrs, each=(length(flts)*length(qtrs))),
                                   month   = qtrs,
                                   week    = week,
                                   fishery = rep(rep(flts, each=length(qtrs)), nyears(ctrl)),
                                   catch   = c(avcatch), 
                                   effort  = c(aveffort),
                                   penalty = -1.0, length=NA, weight=NA, freq=-1)
            
            # remove records with missing values from projection years
            projdat2 <- rbind(projdat[is.element(projdat$fishery, sc_df[sc_df$caeff==1, 'fishery']) & !is.na(projdat$catch),],
                              projdat[is.element(projdat$fishery, sc_df[sc_df$caeff==2, 'fishery']) & !is.na(projdat$effort),])
            
            # set the penalty to 1.0 for those fisheries with standardised CPUE -- maybe ?
            std.fish <- seq(1:n_fisheries(x))[tapply(freq(x)$penalty, freq(x)$fishery, mean)>0]
            projdat2$penalty[is.element(projdat2$fishery, std.fish)] <- 1.0
            
            # set catch/effort to -1 for fisheries projected on effort/catch
            projdat2[is.element(projdat2$fishery, sc_df[sc_df$caeff==1, 'fishery']),'effort'] <- -1
            projdat2[is.element(projdat2$fishery, sc_df[sc_df$caeff==2, 'fishery']),'catch'] <- -1
            
            ## STOCHASTIC PROJECTIONS WITH ESS
            # if an ESS is specified - include length composition data and set first value to ESS
            if(!all(is.na(ess(ctrl)))){
              projdat2 <- generate.ESS(x, ctrl, projdat2, sc_df)
            }

            freq(x) <- rbind(freq(x), projdat2)
            
            data_flags(x)[2,] <- fprojyr(ctrl)  #range(x)['maxyear']+1  #as.numeric(max(avyrs(ctrl)))+1
            data_flags(x)[3,] <- as.numeric(qtrs[1])
            
            #original code
            #lf_range(x)['Datasets'] <- lf_range(x)['Datasets']+nrow(projdat2)
            
            # modified for pseudo obs - but doesn't work for bet and yft
            #lf_range(x)['Datasets'] <- nrow(freq(x)[is.element(freq(x)$length, c(NA,lf_range(x)['LFFirst'])),]) +
            #                           nrow(freq(x)[is.element(freq(x)$weight, c(   lf_range(x)['WFFirst'])),])
            
            # potential solution - see if this breaks anything
            lf_range(x)['Datasets'] <- lf_range(x)['Datasets'] + nrow(unique(projdat2[,1:4]))
            
            slot(x,'range')['maxyear']     <- max(freq(x)$year)
            
            return(x)
          })

    






#' @rdname generate-methods
#' @aliases generate

setMethod("generate", signature(x="MFCLPar", y="MFCLPar"), 
          function(x, y, ...){
     
    stop("generate(MFCLPar, MFCLPar) has been replaced by generate(MFCLPar, MFCLPar, MFCLFrq)")        
            
     # set stochastic recruitment flags
     if(flagval(x, 1, 232)$value == 0)
       flagval(x, 1, 232) <- recPeriod(x, af199=flagval(x, 2, 199)$value, af200=flagval(x, 2, 200)$value)['pf232']
     if(flagval(x, 1, 233)$value == 0)
       flagval(x, 1, 233) <- recPeriod(x, af199=flagval(x, 2, 199)$value, af200=flagval(x, 2, 200)$value)['pf233']
     
          proj.yrs <- dimnames(rel_rec(y))[[2]][!is.element(dimnames(rel_rec(y))[[2]], dimnames(rel_rec(x))[[2]])]
     
     # zero filled objects that you can just copy across   
     rep_rate_dev_coffs(x) <- rep_rate_dev_coffs(y)
     fm_level_devs(x)      <- fm_level_devs(y)
     
     q_dev_coffs(x)        <- q_dev_coffs(y)
     sel_dev_coffs(x)      <- sel_dev_coffs(y)
     sel_dev_coffs2(x)     <- sel_dev_coffs2(y)
     growth_devs_cohort(x) <- growth_devs_cohort(y)
     unused(x)             <- unused(y)
     lagrangian(x)         <- lagrangian(y)
     
     # check that "other lambdas ..." are not specified for par files < 1053
     if(flagval(x, 1, 200)$value<1053 & length(grep("# Other lambdas", lagrangian(x)))>0)
       lagrangian(x) <- lagrangian(x)[1:(grep("Other lambdas", lagrangian(x))-1)]
     
     # non-zero filled objects that you need to append zeroes to 
     eff_dev_coff_incs     <- unlist(lapply(effort_dev_coffs(y),length)) - unlist(lapply(effort_dev_coffs(x),length))
     effort_dev_coffs(x)   <- lapply(1:dimensions(x)["fisheries"], function(g) c(effort_dev_coffs(x)[[g]], rep(0, eff_dev_coff_incs[g])))
     
#     catch_dev_coffs(x)    <- lapply(1:dimensions(x)["fisheries"], function(g) c(catch_dev_coffs(x)[[g]], 
#                                                    rep(0, length(rep_rate_dev_coffs(y)[[g]])-length(catch_dev_coffs(x)[[g]]))))
     
     catch_dev_coffs(x)    <- lapply(1:length(catch_dev_coffs(x)), 
                                     function(g) c(catch_dev_coffs(x)[[g]], rep(0, length(proj.yrs)*dimensions(x)['seasons'])))
     
     region_rec_var(x)     <- window(region_rec_var(x), start=range(x)['minyear'], end=range(y)['maxyear'])
     region_rec_var(x)[is.na(region_rec_var(x))] <- 0
     
     rel_rec(x) <- window(rel_rec(x), start=range(x)['minyear'], end=range(y)['maxyear'])
     rel_rec(x)[,proj.yrs] <- rel_rec(y)[,proj.yrs] 
    
     dimensions(x)         <- dimensions(y)
     range(x)              <- range(y)
     
     return(x)
            
})



setMethod("generate", signature(x="MFCLPar", y="MFCLPar", z="MFCLFrq"), 
          function(x, y, z, ...){
            
            # set stochastic recruitment flags
            if(flagval(x, 1, 232)$value == 0)
              flagval(x, 1, 232) <- recPeriod(x, af199=flagval(x, 2, 199)$value, af200=flagval(x, 2, 200)$value)['pf232']
            if(flagval(x, 1, 233)$value == 0)
              flagval(x, 1, 233) <- recPeriod(x, af199=flagval(x, 2, 199)$value, af200=flagval(x, 2, 200)$value)['pf233']
            
            #proj.yrs <- dimnames(rel_rec(y))[[2]][!is.element(dimnames(rel_rec(y))[[2]], dimnames(rel_rec(x))[[2]])]
            proj.yrs <- seq(range(x)['maxyear']+1, range(x)['maxyear']+(dimensions(y)[2]-dimensions(x)[2])/dimensions(x)[3])
            
            # zero filled objects that you can just copy across   
            rep_rate_dev_coffs(x) <- rep_rate_dev_coffs(y)
            fm_level_devs(x)      <- fm_level_devs(y)
            
            q_dev_coffs(x)        <- q_dev_coffs(y)
            sel_dev_coffs(x)      <- sel_dev_coffs(y)
            sel_dev_coffs2(x)     <- sel_dev_coffs2(y)
            growth_devs_cohort(x) <- growth_devs_cohort(y)
            unused(x)             <- unused(y)
            lagrangian(x)         <- lagrangian(y)
            
            # check that "other lambdas ..." are not specified for par files < 1053
            if(flagval(x, 1, 200)$value<1053 & length(grep("# Other lambdas", lagrangian(x)))>0)
              lagrangian(x) <- lagrangian(x)[1:(grep("Other lambdas", lagrangian(x))-1)]
            
            # non-zero filled objects that you need to append zeroes to 
            eff_dev_coff_incs     <- unlist(lapply(effort_dev_coffs(y),length)) - unlist(lapply(effort_dev_coffs(x),length))
            effort_dev_coffs(x)   <- lapply(1:dimensions(x)["fisheries"], function(g) c(effort_dev_coffs(x)[[g]], rep(0, eff_dev_coff_incs[g])))
            
            # catch_dev_coffs - gets really messy because you may have zero catch obs in some cases and fishery groupings to worry about.
#            catch_dev_coffs(x)    <- lapply(1:length(catch_dev_coffs(x)), 
#                                            function(g) c(catch_dev_coffs(x)[[g]], rep(0, length(proj.yrs)*dimensions(x)['seasons'])))
            
            ## YUKIO's CODE - hacked by RDS to remove dependencies on tidyr and magrittr
            ncgrp<-length(catch_dev_coffs(x))
            ffl29<-flagval(x,-(1:n_fisheries(x)),29)$value  # Obtain fish flags(29) determining the grouping of catchbility
            
            test1 <- unique(with(freq(z), paste(year,month,fishery, sep="_")))
            test2 <- as.data.frame(t(sapply(strsplit(test1, split="_"), "as.numeric",simplify = T)))
            test3 <- data.frame(V1=paste(test2$V1, test2$V2, sep="_"), V2=test2$V3)
            
            nElemByGrp<-vector(mode="numeric",length=length(unique(ffl29)))
            
            for(grp in sort(unique(ffl29))){
              nElemByGrp[grp] <- length(unique(test3[test3$V2 %in% which(ffl29==grp),'V1']))
              nElemFuture<- nElemByGrp[grp]-length(catch_dev_coffs(x)[[grp]])-1 #
              catch_dev_coffs(x)[[grp]]<-c(catch_dev_coffs(x)[[grp]],rep(0,nElemFuture))
            }
          
            
            ### RDS CODE - NOT WORKING
            #nfish <- n_fisheries(z)
            # 3 dimensional table of whch fisheries projected 
            #cdc_proj   <- table(freq(z)[freq(z)$year>range(x)['maxyear'] & is.element(freq(z)$length,c(NA,lf_range(z)['LFFirst'])),c('year','month', 'fishery')])
            
            #cdc_groups <- flagval(x, -1:-nfish, 29)$value
            # fishery groups for those fisheries present in the projection  
            #cdc_groups_rep <- cdc_groups[as.numeric(dimnames(cdc_proj)$fishery)]  #value of fish flag 29 for those fisheries represented in cdc_proj
            
            #cdc_inc    <- lapply(unique(cdc_groups_rep), function(g) rep(0, sum(apply(cdc_proj[,,which(cdc_groups_rep==g)], c(1,2), sum)>0)))
            #names(cdc_inc) <- as.character(unique(cdc_groups))
            
            #catch_dev_coffs(x)    <- lapply(unique(cdc_groups), function(g) c(catch_dev_coffs(x)[[g]], cdc_inc[[as.character(g)]]))
            
            region_rec_var(x)     <- window(region_rec_var(x), start=range(x)['minyear'], end=range(y)['maxyear'])
            region_rec_var(x)[is.na(region_rec_var(x))] <- 0
            
            rel_rec(x) <- window(rel_rec(x), start=range(x)['minyear'], end=range(y)['maxyear'])
            rel_rec(x)[,as.character(proj.yrs)] <- rel_rec(y)[,as.character(proj.yrs)] 
            
            dimensions(x)         <- dimensions(y)
            range(x)              <- range(y)
            
            return(x)
            
          })



###### Yukio's code - I think we're getting the same results. But keeping for further testing
#require(tidyr)
#require(magrittr)


#ncgrp<-length(catch_dev_coffs(par))
#ffl29<-flagval(par,-(1:n_fisheries(par)),29)$value  # Obtain fish flags(29) determining the grouping of catchbility


#if(sum(ffl29)>0){  ## If no grouping of catchability is applied, similar but probably simpler correction may be needed
#  freq(projfrq) %>% unite(col="ymwf",year,month,week,fishery,remove=T)->test0
#  test1<-unique(test0$ymwf)
#  test1 %>% strsplit(.,split="_")->test2
#  test2 %>% sapply(.,"as.numeric",simplify=T) %>% t() %>% as.data.frame() %>%
#    unite("ymw",V1,V2,V3,remove=T)->test3
#  nElemByGrp<-vector(mode="numeric",length=length(unique(ffl29)))
#  for(grp in sort(unique(ffl29))){
#    nElemByGrp[grp]<-which(ffl29==grp) %>% '%in%'(test3$V4, .) %>% test3[.,] %>% '['(.,"ymw") %>%unique() %>% nrow()
#    nElemFuture<- nElemByGrp[grp]-length(catch_dev_coffs(par)[[grp]])-1 # 
#    catch_dev_coffs(projpar)[[grp]]<-c(catch_dev_coffs(par)[[grp]],rep(0,nElemFuture))
#  }
  
  

  
